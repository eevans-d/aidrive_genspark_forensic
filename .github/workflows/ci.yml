name: CI

# Nota: Algunos linters locales pueden marcar como "Context access might be invalid" las referencias a
# secrets (STAGING_* / PROD_*) porque no están definidos en el entorno local. En GitHub Actions
# en tiempo de ejecución sí estarán presentes si fueron cargados. Este es un comportamiento esperado.

on:
  push:
    branches: [ master ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

jobs:
  test-dashboard:
    name: Test Web Dashboard (FastAPI)
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Necesario para actualizar badge de cobertura en README
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r inventario-retail/web_dashboard/requirements.txt
          pip install pytest pytest-cov
      - name: Run full test suite with coverage
        env:
          # Variables mínimas para que los tests pasen auth y no activen rate limit
          DASHBOARD_API_KEY: test-key
          DASHBOARD_RATELIMIT_ENABLED: 'false'
        run: |
          pytest -q tests --cov=inventario-retail/web_dashboard --cov-report=xml --cov-report=term-missing --cov-fail-under=85

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-xml
          path: coverage.xml

      - name: Extraer porcentaje de cobertura
        id: cov
        run: |
          python -c "import xml.etree.ElementTree as ET;root=ET.parse('coverage.xml').getroot();import math;line_rate=float(root.attrib.get('line-rate',0));percent=int(round(line_rate*100));print(f'coverage={percent}');open('coverage_percent.txt','w').write(str(percent))"
          echo "percent=$(cat coverage_percent.txt)" >> $GITHUB_OUTPUT

      - name: Actualizar badge de cobertura en README (si cambia)
        run: |
          PCT=${{ steps.cov.outputs.percent }}
          COLOR=red
          if [ "$PCT" -ge 85 ]; then COLOR=brightgreen; elif [ "$PCT" -ge 75 ]; then COLOR=yellowgreen; elif [ "$PCT" -ge 60 ]; then COLOR=yellow; fi
          BADGE="[![Coverage](https://img.shields.io/badge/coverage-${PCT}%25-${COLOR}.svg)](#)"
          if grep -q "\[!\[Coverage\](https://img.shields.io/badge/coverage-" README.md; then
            # Reemplazar línea que contiene el badge Coverage
            sed -i "s|\[!\[Coverage\](https://img.shields.io/badge/coverage-[^)]*)|$BADGE|" README.md
          else
            # Insertar debajo del badge de CI
            sed -i "1a $BADGE" README.md
          fi
          if git diff --quiet README.md; then echo "Sin cambios en README"; exit 0; fi
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          git add README.md
          git commit -m "docs(badge): actualiza badge cobertura a ${PCT}%" || true
          git push || true

  docker-build-push:
    name: Docker Build & Push (GHCR)
    runs-on: ubuntu-latest
    needs: [test-dashboard]
    # Construye también en ejecuciones manuales
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && (github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/'))) }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest
            type=sha
            type=ref,event=tag

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: inventario-retail/web_dashboard/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  smoke-test-image:
    name: Smoke Test Docker Image
    runs-on: ubuntu-latest
    needs: [docker-build-push]
    steps:
      - name: Pull image
        run: |
          docker pull ghcr.io/${{ github.repository }}:latest
      - name: Run container
        run: |
          docker run -d --rm --name dashboard -p 8080:8080 \
            -e DASHBOARD_API_KEY=test-key \
            ghcr.io/${{ github.repository }}:latest
          # Esperar a que arranque
          for i in {1..30}; do
            curl -fsS -H 'X-API-Key: test-key' http://localhost:8080/health && break || sleep 1;
          done
      - name: Probe health and metrics
        run: |
          curl -fsS -H 'X-API-Key: test-key' http://localhost:8080/health | head -n 1
          # /metrics requiere API Key según docs; si falla, no romper
          curl -fsS -H 'X-API-Key: test-key' http://localhost:8080/metrics | head -n 5 || true
      - name: Stop container
        if: always()
        run: docker stop dashboard

  trivy-scan-image:
    name: Trivy Image Scan (advisory)
    runs-on: ubuntu-latest
    needs: [docker-build-push]
    continue-on-error: true
    permissions:
      contents: read
    steps:
      - name: Pull image
        run: docker pull ghcr.io/${{ github.repository }}:latest
      - name: Run Trivy scan (image:latest)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ github.repository }}:latest
          format: 'table'
          severity: 'MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: true
          exit-code: '0'

  staging-secrets-check:
    name: Check Staging Secrets
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/master') }}
    outputs:
      staging_ready: ${{ steps.eval.outputs.ready }}
      missing: ${{ steps.eval.outputs.missing }}
    steps:
      - name: Evaluate required staging secrets
        id: eval
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_KEY: ${{ secrets.STAGING_KEY }}
          STAGING_GHCR_TOKEN: ${{ secrets.STAGING_GHCR_TOKEN }}
          STAGING_DASHBOARD_API_KEY: ${{ secrets.STAGING_DASHBOARD_API_KEY }}
        run: |
          set -euo pipefail
          missing=()
          for var in STAGING_HOST STAGING_USER STAGING_KEY STAGING_GHCR_TOKEN STAGING_DASHBOARD_API_KEY; do
            if [ -z "${!var}" ]; then
              missing+=("$var")
            fi
          done
          if [ ${#missing[@]} -eq 0 ]; then
            echo "Todos los secretos de staging requeridos están presentes." >&2
            echo "ready=true" >> $GITHUB_OUTPUT
            echo "missing=" >> $GITHUB_OUTPUT
          else
            echo "Faltan secretos de staging: ${missing[*]}" >&2
            echo "ready=false" >> $GITHUB_OUTPUT
            echo "missing=${missing[*]}" >> $GITHUB_OUTPUT
          fi
      - name: Summary
        run: |
          if [ "${{ steps.eval.outputs.ready }}" = "true" ]; then
            echo "✅ Staging listo para deploy." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Staging NO listo para deploy." >> $GITHUB_STEP_SUMMARY
            echo "Faltan: ${{ steps.eval.outputs.missing }}" >> $GITHUB_STEP_SUMMARY
          fi

  deploy-staging:
    name: Deploy to Staging (manual)
    runs-on: ubuntu-latest
    needs: [smoke-test-image, trivy-scan-image, staging-secrets-check]
    # Ejecutar en push a master o manual si todos los secretos requeridos están listos
    if: ${{ ((github.event_name == 'push' && github.ref == 'refs/heads/master') || github.event_name == 'workflow_dispatch') && needs.staging-secrets-check.outputs.staging_ready == 'true' }}
    environment:
      name: staging
    # Requiere secretos definidos en el repositorio:
    # STAGING_HOST, STAGING_USER, STAGING_KEY (PEM), STAGING_GHCR_TOKEN, STAGING_DASHBOARD_API_KEY
    steps:
      - name: Copy compose files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_KEY }}
          source: "deploy/compose/*"
          target: "~/minimarket-deploy"
      - name: Deploy over SSH (docker compose)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_KEY }}
          script: |
            set -euo pipefail
            export IMAGE_TAG=latest
            export DASHBOARD_API_KEY='${{ secrets.STAGING_DASHBOARD_API_KEY }}'
            if [ -n "${{ secrets.STAGING_DASHBOARD_UI_API_KEY }}" ]; then
              export DASHBOARD_UI_API_KEY='${{ secrets.STAGING_DASHBOARD_UI_API_KEY }}'
            fi
            cd ~/minimarket-deploy/deploy/compose
            echo ${{ secrets.STAGING_GHCR_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker compose -f docker-compose.dashboard.yml pull
            docker compose -f docker-compose.dashboard.yml up -d
            for i in {1..30}; do curl -fsS -H "X-API-Key: ${DASHBOARD_API_KEY}" http://localhost:8080/health && break || sleep 1; done
      - name: Post-deploy smoke checks
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_KEY }}
          script: |
            set -euo pipefail
            BASE="http://localhost:8080"
            echo "[SMOKE] Iniciando verificación básica"
            echo "1) /health (200 o 503)"
            HCODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ secrets.STAGING_DASHBOARD_API_KEY }}" "$BASE/health" || true)
            if [ "$HCODE" != "200" ] && [ "$HCODE" != "503" ]; then echo "FAIL /health => $HCODE"; exit 1; fi
            echo "2) /api/summary sin auth (401)"
            NOAUTH=$(curl -s -o /dev/null -w "%{http_code}" "$BASE/api/summary" || true)
            [ "$NOAUTH" = "401" ] || { echo "FAIL /api/summary sin API Key => $NOAUTH"; exit 1; }
            echo "3) /api/summary con auth (200 o 500)"
            AUTH=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ secrets.STAGING_DASHBOARD_API_KEY }}" "$BASE/api/summary" || true)
            if [ "$AUTH" != "200" ] && [ "$AUTH" != "500" ]; then echo "FAIL /api/summary con API Key => $AUTH"; exit 1; fi
            echo "4) /metrics (200 y contiene dashboard_requests_total)"
            MC=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ secrets.STAGING_DASHBOARD_API_KEY }}" "$BASE/metrics" || true)
            [ "$MC" = "200" ] || { echo "FAIL /metrics status => $MC"; exit 1; }
            curl -s -H "X-API-Key: ${{ secrets.STAGING_DASHBOARD_API_KEY }}" "$BASE/metrics" | grep -q 'dashboard_requests_total' || { echo "FAIL /metrics sin dashboard_requests_total"; exit 1; }
            echo "5) Export CSV summary (200)"
            EC=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ secrets.STAGING_DASHBOARD_API_KEY }}" "$BASE/api/export/summary.csv" || true)
            [ "$EC" = "200" ] || { echo "FAIL /api/export/summary.csv => $EC"; exit 1; }
            echo "[SMOKE] OK"

  staging-metrics-check:
    name: Staging Metrics Check (advisory)
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: ${{ needs.deploy-staging.result == 'success' }}
    steps:
      - name: Checkout (script only)
        uses: actions/checkout@v4
      - name: Run metrics check script over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_KEY }}
          script: |
            set -euo pipefail
            # Descargar script actualizado desde repo (alternativamente podríamos desplegarlo junto a compose)
            mkdir -p ~/dashboard-tools
            cat > ~/dashboard-tools/check_metrics_dashboard.sh <<'EOS'
            #!/usr/bin/env bash
            set -euo pipefail
            API_KEY='${{ secrets.STAGING_DASHBOARD_API_KEY }}'
            RAW=$(curl -fsS -H "X-API-Key: $API_KEY" http://localhost:8080/metrics || true)
            if [ -z "$RAW" ]; then echo "[WARN] No se pudo obtener métricas"; exit 0; fi
            req_total=$(echo "$RAW" | awk '/^dashboard_requests_total /{print $2; exit}')
            err_total=$(echo "$RAW" | awk '/^dashboard_errors_total /{print $2; exit}')
            err_total=${err_total:-0}
            if [ -n "$req_total" ] && [ "$req_total" -gt 0 ] 2>/dev/null; then
              pct=$(awk -v e="$err_total" -v r="$req_total" 'BEGIN{printf "%.2f", (e/r)*100}')
              echo "Requests=$req_total Errors=$err_total Error%=$pct"
              awk -v p="$pct" 'BEGIN{ if (p>2) print "[ALERTA] Error% supera 2"; else print "[OK] Error% dentro de umbral" }'
            else
              echo "[INFO] No hay tráfico suficiente (requests=0)"
            fi
            p95=$(echo "$RAW" | awk '/^dashboard_request_duration_ms_p95 /{print $2; exit}')
            if [ -n "$p95" ]; then echo "p95(ms)=$p95"; fi
            EOS
            chmod +x ~/dashboard-tools/check_metrics_dashboard.sh
            ~/dashboard-tools/check_metrics_dashboard.sh || true

  deploy-production:
    name: Deploy to Production (tags)
    runs-on: ubuntu-latest
    needs: [docker-build-push]
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
    environment:
      name: production
    # Requiere secretos: PROD_HOST, PROD_USER, PROD_KEY, PROD_GHCR_TOKEN, PROD_DASHBOARD_API_KEY
    steps:
      - name: Compute image tag from ref
        id: vars
        run: echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
      - name: Copy compose files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_KEY }}
          source: "deploy/compose/*"
          target: "~/minimarket-deploy"
      - name: Deploy over SSH (docker compose)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_KEY }}
          script: |
            set -euo pipefail
            export IMAGE_TAG='${{ steps.vars.outputs.tag }}'
            export DASHBOARD_API_KEY='${{ secrets.PROD_DASHBOARD_API_KEY }}'
            if [ -n "${{ secrets.PROD_DASHBOARD_UI_API_KEY }}" ]; then
              export DASHBOARD_UI_API_KEY='${{ secrets.PROD_DASHBOARD_UI_API_KEY }}'
            fi
            cd ~/minimarket-deploy/deploy/compose
            echo ${{ secrets.PROD_GHCR_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker compose -f docker-compose.dashboard.yml pull
            docker compose -f docker-compose.dashboard.yml up -d
            for i in {1..30}; do curl -fsS -H "X-API-Key: ${DASHBOARD_API_KEY}" http://localhost:8080/health && break || sleep 1; done

  lint-security:
    name: Lint & Security (non-blocking)
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install linters
        run: |
          python -m pip install --upgrade pip
          pip install ruff bandit

      - name: Ruff check (advisory)
        run: |
          ruff check . || true

      - name: Bandit security scan (advisory)
        run: |
          bandit -q -r . || true
