<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scripts de Deployment y Mantenimiento - BI Orchestrator v3.1</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body class="bg-gray-50 text-gray-800">
    <!-- Header -->
    <div class="bg-gradient-to-r from-blue-900 via-purple-900 to-indigo-900 text-white py-6">
        <div class="container mx-auto px-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold flex items-center">
                        <i class="fas fa-cogs mr-3"></i>
                        Scripts de Deployment y Mantenimiento
                    </h1>
                    <p class="text-xl text-blue-200 mt-2">Business Intelligence Orchestrator v3.1</p>
                </div>
                <div class="text-right">
                    <div class="bg-green-500 text-white px-4 py-2 rounded-full text-sm font-semibold">
                        <i class="fas fa-check-circle mr-1"></i> PRODUCCI√ìN READY
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-6">
        <!-- √çndice de Scripts -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <i class="fas fa-list mr-3 text-blue-600"></i>
                √çndice de Scripts y Configuraciones
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                    <h3 class="font-semibold text-blue-800 mb-2">
                        <i class="fas fa-play-circle mr-2"></i>Scripts de Control
                    </h3>
                    <ul class="text-sm text-blue-600 space-y-1">
                        <li>‚Ä¢ start.sh - Iniciar sistema</li>
                        <li>‚Ä¢ stop.sh - Detener sistema</li>
                        <li>‚Ä¢ restart.sh - Reiniciar servicios</li>
                        <li>‚Ä¢ status.sh - Estado del sistema</li>
                    </ul>
                </div>
                <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                    <h3 class="font-semibold text-green-800 mb-2">
                        <i class="fas fa-tools mr-2"></i>Scripts de Mantenimiento
                    </h3>
                    <ul class="text-sm text-green-600 space-y-1">
                        <li>‚Ä¢ maintenance.sh - Mantenimiento</li>
                        <li>‚Ä¢ backup.sh - Respaldos</li>
                        <li>‚Ä¢ logs.sh - Gesti√≥n de logs</li>
                        <li>‚Ä¢ health-check.sh - Monitoreo</li>
                    </ul>
                </div>
                <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                    <h3 class="font-semibold text-purple-800 mb-2">
                        <i class="fas fa-cloud-upload-alt mr-2"></i>CI/CD y Deployment
                    </h3>
                    <ul class="text-sm text-purple-600 space-y-1">
                        <li>‚Ä¢ .github/workflows/deploy.yml</li>
                        <li>‚Ä¢ Dockerfile.deploy</li>
                        <li>‚Ä¢ nginx.conf</li>
                        <li>‚Ä¢ environment configs</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Script 1: start.sh -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <i class="fas fa-play text-green-600 mr-3"></i>
                start.sh - Inicializaci√≥n del Sistema
            </h2>
            <div class="bg-gray-800 rounded-lg p-4 overflow-x-auto">
                <pre class="text-green-400 text-sm"><code class="language-bash">#!/bin/bash

# =============================================================================
# Business Intelligence Orchestrator v3.1 - Sistema de Inicio
# =============================================================================

set -e

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuraci√≥n
PROJECT_NAME="bi-orchestrator"
COMPOSE_FILE="docker-compose.yml"
ENV_FILE=".env"

echo -e "${BLUE}üöÄ Iniciando Business Intelligence Orchestrator v3.1${NC}"
echo "=============================================================="

# Verificar prerrequisitos
check_prerequisites() {
    echo -e "${YELLOW}üìã Verificando prerrequisitos...${NC}"
    
    command -v docker >/dev/null 2>&1 || { 
        echo -e "${RED}‚ùå Docker no est√° instalado${NC}" 
        exit 1 
    }
    
    command -v docker-compose >/dev/null 2>&1 || { 
        echo -e "${RED}‚ùå Docker Compose no est√° instalado${NC}" 
        exit 1 
    }
    
    if [ ! -f "$ENV_FILE" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Creando archivo .env desde template...${NC}"
        cp .env.template .env
    fi
    
    echo -e "${GREEN}‚úÖ Prerrequisitos verificados${NC}"
}

# Crear red de Docker si no existe
create_network() {
    echo -e "${YELLOW}üîó Configurando red de Docker...${NC}"
    
    if ! docker network ls | grep -q "${PROJECT_NAME}_network"; then
        docker network create ${PROJECT_NAME}_network
        echo -e "${GREEN}‚úÖ Red ${PROJECT_NAME}_network creada${NC}"
    else
        echo -e "${GREEN}‚úÖ Red ya existe${NC}"
    fi
}

# Crear vol√∫menes necesarios
create_volumes() {
    echo -e "${YELLOW}üíæ Configurando vol√∫menes...${NC}"
    
    docker volume create ${PROJECT_NAME}_postgres_data 2>/dev/null || true
    docker volume create ${PROJECT_NAME}_redis_data 2>/dev/null || true
    docker volume create ${PROJECT_NAME}_n8n_data 2>/dev/null || true
    docker volume create ${PROJECT_NAME}_grafana_data 2>/dev/null || true
    
    echo -e "${GREEN}‚úÖ Vol√∫menes configurados${NC}"
}

# Inicializar base de datos
init_database() {
    echo -e "${YELLOW}üóÑÔ∏è  Inicializando base de datos...${NC}"
    
    # Esperar a que PostgreSQL est√© listo
    echo "Esperando PostgreSQL..."
    docker-compose exec -T postgres sh -c 'until pg_isready -U $POSTGRES_USER; do sleep 1; done'
    
    # Ejecutar esquema si es primera vez
    if [ -f "supabase/schema.sql" ]; then
        docker-compose exec -T postgres psql -U bi_user -d bi_orchestrator -f /docker-entrypoint-initdb.d/schema.sql
        echo -e "${GREEN}‚úÖ Schema de base de datos aplicado${NC}"
    fi
    
    # Ejecutar funciones
    if [ -f "supabase/functions.sql" ]; then
        docker-compose exec -T postgres psql -U bi_user -d bi_orchestrator -f /docker-entrypoint-initdb.d/functions.sql
        echo -e "${GREEN}‚úÖ Funciones de base de datos aplicadas${NC}"
    fi
}

# Importar workflows de N8N
import_n8n_workflows() {
    echo -e "${YELLOW}üîÑ Importando workflows de N8N...${NC}"
    
    # Esperar a que N8N est√© listo
    sleep 30
    
    # Importar cada workflow
    for workflow_file in n8n-workflows/*.json; do
        if [ -f "$workflow_file" ]; then
            workflow_name=$(basename "$workflow_file" .json)
            echo "Importando $workflow_name..."
            
            curl -X POST "http://localhost:5678/api/v1/workflows" \
                -H "Content-Type: application/json" \
                -d @"$workflow_file" || true
        fi
    done
    
    echo -e "${GREEN}‚úÖ Workflows de N8N importados${NC}"
}

# Verificar salud de servicios
health_check() {
    echo -e "${YELLOW}üè• Verificando salud de servicios...${NC}"
    
    services=("postgres:5432" "redis:6379" "n8n:5678" "web-monitor:8000")
    
    for service in "${services[@]}"; do
        IFS=':' read -ra ADDR <<< "$service"
        service_name=${ADDR[0]}
        port=${ADDR[1]}
        
        echo -n "Verificando $service_name..."
        if timeout 30 bash -c "until echo > /dev/tcp/localhost/$port; do sleep 1; done" 2>/dev/null; then
            echo -e " ${GREEN}‚úÖ${NC}"
        else
            echo -e " ${RED}‚ùå${NC}"
        fi
    done
}

# Mostrar URLs de acceso
show_urls() {
    echo ""
    echo -e "${BLUE}üåê URLs de Acceso:${NC}"
    echo "=============================================================="
    echo -e "${GREEN}üìä Frontend Dashboard:${NC}     http://localhost:3000"
    echo -e "${GREEN}üîÑ N8N Workflows:${NC}          http://localhost:5678"
    echo -e "${GREEN}üìà Grafana Monitoring:${NC}     http://localhost:3001"
    echo -e "${GREEN}üîç WEB Autom√°tico:${NC}         http://localhost:8000"
    echo -e "${GREEN}üîå API Gateway:${NC}            http://localhost:8080"
    echo -e "${GREEN}üìã Admin Panel:${NC}            http://localhost:8090"
    echo "=============================================================="
}

# Funci√≥n principal
main() {
    check_prerequisites
    create_network
    create_volumes
    
    echo -e "${YELLOW}üê≥ Iniciando contenedores...${NC}"
    docker-compose -f $COMPOSE_FILE up -d
    
    echo -e "${YELLOW}‚è≥ Esperando que los servicios est√©n listos...${NC}"
    sleep 45
    
    init_database
    import_n8n_workflows
    health_check
    show_urls
    
    echo ""
    echo -e "${GREEN}üéâ ¬°Business Intelligence Orchestrator v3.1 iniciado correctamente!${NC}"
    echo -e "${BLUE}üìù Para ver logs: ./scripts/logs.sh${NC}"
    echo -e "${BLUE}üìä Para ver estado: ./scripts/status.sh${NC}"
}

# Ejecutar funci√≥n principal
main "$@"</code></pre>
            </div>
        </div>

        <!-- Script 2: stop.sh -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <i class="fas fa-stop text-red-600 mr-3"></i>
                stop.sh - Detener Sistema Completo
            </h2>
            <div class="bg-gray-800 rounded-lg p-4 overflow-x-auto">
                <pre class="text-green-400 text-sm"><code class="language-bash">#!/bin/bash

# =============================================================================
# Business Intelligence Orchestrator v3.1 - Sistema de Parada
# =============================================================================

set -e

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

PROJECT_NAME="bi-orchestrator"
COMPOSE_FILE="docker-compose.yml"

echo -e "${RED}üõë Deteniendo Business Intelligence Orchestrator v3.1${NC}"
echo "=============================================================="

# Funci√≥n para detener gracefully
graceful_shutdown() {
    echo -e "${YELLOW}‚èπÔ∏è  Iniciando parada gradual de servicios...${NC}"
    
    # Detener frontend primero (para evitar nuevas conexiones)
    echo "Deteniendo frontend..."
    docker-compose stop frontend || true
    
    # Detener APIs y servicios de aplicaci√≥n
    echo "Deteniendo APIs y microservicios..."
    docker-compose stop api-gateway data-analytics competitive-intelligence || true
    docker-compose stop business-metrics admin-dashboard realtime-processing || true
    
    # Detener N8N workflows
    echo "Deteniendo workflows N8N..."
    docker-compose stop n8n || true
    
    # Detener WEB AUTOM√ÅTICO COMPETITIVO
    echo "Deteniendo WEB Autom√°tico Competitivo..."
    docker-compose stop web-monitor || true
    
    # Detener servicios de monitoreo
    echo "Deteniendo monitoreo..."
    docker-compose stop grafana prometheus loki || true
    
    # Detener servicios de datos (√∫ltimo)
    echo "Deteniendo servicios de datos..."
    docker-compose stop redis-master redis-replica postgres || true
    
    echo -e "${GREEN}‚úÖ Parada gradual completada${NC}"
}

# Funci√≥n para backup antes de detener
backup_before_stop() {
    if [ "$1" != "--no-backup" ]; then
        echo -e "${YELLOW}üíæ Creando backup antes de detener...${NC}"
        ./scripts/backup.sh --quick || echo -e "${YELLOW}‚ö†Ô∏è  Backup fall√≥, continuando...${NC}"
    fi
}

# Funci√≥n para limpiar recursos
cleanup_resources() {
    if [ "$1" = "--cleanup" ]; then
        echo -e "${YELLOW}üßπ Limpiando recursos...${NC}"
        
        # Limpiar contenedores detenidos
        docker container prune -f
        
        # Limpiar im√°genes sin usar
        docker image prune -f
        
        # Limpiar redes sin usar
        docker network prune -f
        
        echo -e "${GREEN}‚úÖ Recursos limpiados${NC}"
    fi
}

# Funci√≥n para mostrar estado final
show_final_status() {
    echo -e "${BLUE}üìä Estado final de contenedores:${NC}"
    docker-compose ps
    
    echo ""
    echo -e "${BLUE}üíæ Vol√∫menes de datos conservados:${NC}"
    docker volume ls | grep ${PROJECT_NAME} || echo "No hay vol√∫menes del proyecto"
}

# Funci√≥n para parada forzada
force_stop() {
    echo -e "${RED}‚ö° Parada forzada iniciada...${NC}"
    docker-compose kill
    docker-compose down
    echo -e "${RED}üî• Parada forzada completada${NC}"
}

# Mostrar ayuda
show_help() {
    echo "Uso: $0 [OPCIONES]"
    echo ""
    echo "Opciones:"
    echo "  --no-backup     No crear backup antes de detener"
    echo "  --cleanup       Limpiar recursos Docker no utilizados"
    echo "  --force         Parada forzada inmediata (kill)"
    echo "  --help          Mostrar esta ayuda"
    echo ""
    echo "Ejemplos:"
    echo "  $0              # Parada normal con backup"
    echo "  $0 --no-backup # Parada sin backup"
    echo "  $0 --force      # Parada forzada inmediata"
}

# Funci√≥n principal
main() {
    # Parsear argumentos
    FORCE_STOP=false
    NO_BACKUP=false
    CLEANUP=false
    
    for arg in "$@"; do
        case $arg in
            --force)
                FORCE_STOP=true
                ;;
            --no-backup)
                NO_BACKUP=true
                ;;
            --cleanup)
                CLEANUP=true
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}‚ùå Argumento desconocido: $arg${NC}"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Ejecutar parada seg√∫n par√°metros
    if [ "$FORCE_STOP" = true ]; then
        force_stop
    else
        if [ "$NO_BACKUP" = false ]; then
            backup_before_stop
        else
            backup_before_stop --no-backup
        fi
        
        graceful_shutdown
        
        # Detener completamente
        echo -e "${YELLOW}üîΩ Deteniendo y removiendo contenedores...${NC}"
        docker-compose down
    fi
    
    # Limpiar si se solicita
    if [ "$CLEANUP" = true ]; then
        cleanup_resources --cleanup
    fi
    
    show_final_status
    
    echo ""
    echo -e "${GREEN}‚úÖ Business Intelligence Orchestrator v3.1 detenido correctamente${NC}"
    echo -e "${BLUE}üîÑ Para reiniciar: ./scripts/start.sh${NC}"
    echo -e "${BLUE}üìä Para ver estado: ./scripts/status.sh${NC}"
}

# Verificar si est√° ejecut√°ndose
if ! docker-compose ps | grep -q "Up"; then
    echo -e "${YELLOW}‚ö†Ô∏è  El sistema no parece estar ejecut√°ndose${NC}"
    docker-compose ps
    exit 0
fi

# Ejecutar funci√≥n principal
main "$@"</code></pre>
            </div>
        </div>

        <!-- Script 3: status.sh -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <i class="fas fa-heartbeat text-blue-600 mr-3"></i>
                status.sh - Monitoreo de Estado del Sistema
            </h2>
            <div class="bg-gray-800 rounded-lg p-4 overflow-x-auto">
                <pre class="text-green-400 text-sm"><code class="language-bash">#!/bin/bash

# =============================================================================
# Business Intelligence Orchestrator v3.1 - Monitor de Estado
# =============================================================================

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

PROJECT_NAME="bi-orchestrator"

echo -e "${BLUE}üìä Business Intelligence Orchestrator v3.1 - Estado del Sistema${NC}"
echo "=============================================================================="

# Funci√≥n para verificar conectividad de servicio
check_service_connectivity() {
    local service_name=$1
    local host=$2
    local port=$3
    local timeout=${4:-5}
    
    if timeout $timeout bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null; then
        echo -e "${GREEN}‚úÖ $service_name${NC} - Conectivo en $host:$port"
        return 0
    else
        echo -e "${RED}‚ùå $service_name${NC} - No conectivo en $host:$port"
        return 1
    fi
}

# Funci√≥n para obtener m√©tricas de contenedor
get_container_metrics() {
    local container_name=$1
    
    if docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -q "$container_name"; then
        local stats=$(docker stats --no-stream --format "table {{.CPUPerc}}\t{{.MemUsage}}" "$container_name" 2>/dev/null | tail -n 1)
        echo "$stats"
    else
        echo "N/A - Contenedor no ejecut√°ndose"
    fi
}

# Header del sistema
show_system_header() {
    echo -e "${CYAN}üñ•Ô∏è  INFORMACI√ìN DEL SISTEMA${NC}"
    echo "------------------------------------------------------------------------------"
    echo -e "Fecha/Hora: ${YELLOW}$(date)${NC}"
    echo -e "Usuario: ${YELLOW}$(whoami)${NC}"
    echo -e "Host: ${YELLOW}$(hostname)${NC}"
    echo -e "Uptime: ${YELLOW}$(uptime | cut -d',' -f1 | cut -d' ' -f4-)${NC}"
    echo ""
}

# Estado de Docker y Docker Compose
show_docker_status() {
    echo -e "${CYAN}üê≥ ESTADO DE DOCKER${NC}"
    echo "------------------------------------------------------------------------------"
    
    if command -v docker >/dev/null 2>&1; then
        docker_version=$(docker --version | cut -d' ' -f3 | cut -d',' -f1)
        echo -e "Docker: ${GREEN}‚úÖ Instalado${NC} - Versi√≥n $docker_version"
        
        if docker info >/dev/null 2>&1; then
            echo -e "Docker Daemon: ${GREEN}‚úÖ Ejecut√°ndose${NC}"
        else
            echo -e "Docker Daemon: ${RED}‚ùå No disponible${NC}"
            return 1
        fi
    else
        echo -e "Docker: ${RED}‚ùå No instalado${NC}"
        return 1
    fi
    
    if command -v docker-compose >/dev/null 2>&1; then
        compose_version=$(docker-compose --version | cut -d' ' -f3 | cut -d',' -f1)
        echo -e "Docker Compose: ${GREEN}‚úÖ Instalado${NC} - Versi√≥n $compose_version"
    else
        echo -e "Docker Compose: ${RED}‚ùå No instalado${NC}"
    fi
    echo ""
}

# Estado de contenedores
show_containers_status() {
    echo -e "${CYAN}üì¶ ESTADO DE CONTENEDORES${NC}"
    echo "------------------------------------------------------------------------------"
    
    if docker-compose ps 2>/dev/null | grep -q "Up\|Exit"; then
        echo -e "${BLUE}Contenedores del proyecto:${NC}"
        docker-compose ps --format "table {{.Name}}\t{{.State}}\t{{.Status}}\t{{.Ports}}"
        
        echo ""
        echo -e "${BLUE}Uso de recursos por contenedor:${NC}"
        printf "%-25s %-15s %-20s\n" "CONTENEDOR" "CPU %" "MEMORIA"
        echo "------------------------------------------------------------------------------"
        
        containers=$(docker-compose ps -q)
        for container in $containers; do
            if [ ! -z "$container" ]; then
                name=$(docker inspect --format='{{.Name}}' "$container" | sed 's/\///g')
                metrics=$(get_container_metrics "$container")
                printf "%-25s %s\n" "$name" "$metrics"
            fi
        done
    else
        echo -e "${YELLOW}‚ö†Ô∏è  No hay contenedores del proyecto ejecut√°ndose${NC}"
        echo ""
        echo -e "${BLUE}Para iniciar el sistema:${NC} ./scripts/start.sh"
    fi
    echo ""
}

# Conectividad de servicios principales
show_services_connectivity() {
    echo -e "${CYAN}üîó CONECTIVIDAD DE SERVICIOS${NC}"
    echo "------------------------------------------------------------------------------"
    
    # Servicios principales con sus puertos
    declare -A services=(
        ["PostgreSQL"]="localhost 5432"
        ["Redis Master"]="localhost 6379"
        ["N8N Workflows"]="localhost 5678"
        ["API Gateway"]="localhost 8080"
        ["Frontend"]="localhost 3000"
        ["Grafana"]="localhost 3001"
        ["WEB Autom√°tico"]="localhost 8000"
        ["Admin Panel"]="localhost 8090"
    )
    
    connected_count=0
    total_count=${#services[@]}
    
    for service in "${!services[@]}"; do
        IFS=' ' read -ra ADDR <<< "${services[$service]}"
        host=${ADDR[0]}
        port=${ADDR[1]}
        
        if check_service_connectivity "$service" "$host" "$port" 3; then
            ((connected_count++))
        fi
    done
    
    echo ""
    echo -e "${BLUE}Resumen de conectividad: ${connected_count}/${total_count} servicios activos${NC}"
    
    if [ $connected_count -eq $total_count ]; then
        echo -e "${GREEN}üéâ Todos los servicios est√°n conectivos${NC}"
    elif [ $connected_count -eq 0 ]; then
        echo -e "${RED}‚ö†Ô∏è  Ning√∫n servicio est√° conectivo - Sistema posiblemente detenido${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Algunos servicios no est√°n disponibles${NC}"
    fi
    echo ""
}

# Estado de vol√∫menes y datos
show_volumes_status() {
    echo -e "${CYAN}üíæ VOL√öMENES Y DATOS${NC}"
    echo "------------------------------------------------------------------------------"
    
    volumes=$(docker volume ls --format "{{.Name}}" | grep "$PROJECT_NAME" || true)
    
    if [ ! -z "$volumes" ]; then
        echo -e "${BLUE}Vol√∫menes del proyecto:${NC}"
        printf "%-30s %-15s %-20s\n" "VOLUMEN" "DRIVER" "TAMA√ëO APROX"
        echo "------------------------------------------------------------------------------"
        
        for volume in $volumes; do
            driver=$(docker volume inspect "$volume" --format '{{.Driver}}')
            # Obtener tama√±o aproximado del volumen
            size=$(docker run --rm -v "$volume":/data alpine du -sh /data 2>/dev/null | cut -f1 || echo "N/A")
            printf "%-30s %-15s %-20s\n" "$volume" "$driver" "$size"
        done
    else
        echo -e "${YELLOW}‚ö†Ô∏è  No se encontraron vol√∫menes del proyecto${NC}"
    fi
    echo ""
}

# Logs recientes y errores
show_recent_logs() {
    echo -e "${CYAN}üìã LOGS RECIENTES Y ERRORES${NC}"
    echo "------------------------------------------------------------------------------"
    
    if docker-compose ps -q >/dev/null 2>&1; then
        echo -e "${BLUE}Errores recientes en los √∫ltimos 5 minutos:${NC}"
        
        # Buscar errores en logs de los √∫ltimos 5 minutos
        error_count=0
        containers=$(docker-compose ps -q)
        
        for container in $containers; do
            if [ ! -z "$container" ]; then
                name=$(docker inspect --format='{{.Name}}' "$container" | sed 's/\///g')
                errors=$(docker logs --since="5m" "$container" 2>&1 | grep -i "error\|exception\|failed\|fatal" | head -3)
                
                if [ ! -z "$errors" ]; then
                    echo -e "${RED}‚ùå $name:${NC}"
                    echo "$errors" | sed 's/^/  /'
                    ((error_count++))
                fi
            fi
        done
        
        if [ $error_count -eq 0 ]; then
            echo -e "${GREEN}‚úÖ No se encontraron errores recientes${NC}"
        else
            echo ""
            echo -e "${YELLOW}üí° Para ver logs detallados: ./scripts/logs.sh [servicio]${NC}"
        fi
    else
        echo -e "${YELLOW}‚ö†Ô∏è  No hay contenedores ejecut√°ndose para revisar logs${NC}"
    fi
    echo ""
}

# URLs de acceso r√°pido
show_quick_access_urls() {
    echo -e "${CYAN}üåê ACCESO R√ÅPIDO${NC}"
    echo "------------------------------------------------------------------------------"
    echo -e "${GREEN}üìä Frontend Dashboard:${NC}      http://localhost:3000"
    echo -e "${GREEN}üîÑ N8N Workflows:${NC}           http://localhost:5678"
    echo -e "${GREEN}üìà Grafana Monitoring:${NC}      http://localhost:3001"
    echo -e "${GREEN}üîç WEB Autom√°tico:${NC}          http://localhost:8000"
    echo -e "${GREEN}üîå API Gateway:${NC}             http://localhost:8080"
    echo -e "${GREEN}üìã Admin Panel:${NC}             http://localhost:8090"
    echo -e "${GREEN}üìñ API Documentation:${NC}       http://localhost:8080/docs"
    echo ""
}

# Scripts de mantenimiento disponibles
show_available_scripts() {
    echo -e "${CYAN}üõ†Ô∏è  SCRIPTS DISPONIBLES${NC}"
    echo "------------------------------------------------------------------------------"
    echo -e "${BLUE}Control del sistema:${NC}"
    echo "  ./scripts/start.sh      - Iniciar sistema completo"
    echo "  ./scripts/stop.sh       - Detener sistema"
    echo "  ./scripts/restart.sh    - Reiniciar servicios"
    echo ""
    echo -e "${BLUE}Mantenimiento:${NC}"
    echo "  ./scripts/logs.sh       - Ver logs de servicios"
    echo "  ./scripts/backup.sh     - Crear respaldos"
    echo "  ./scripts/maintenance.sh - Mantenimiento programado"
    echo ""
    echo -e "${BLUE}Monitoreo:${NC}"
    echo "  ./scripts/status.sh     - Este script (estado actual)"
    echo "  watch ./scripts/status.sh - Monitor en tiempo real"
    echo ""
}

# Funci√≥n principal
main() {
    clear
    show_system_header
    show_docker_status
    show_containers_status
    show_services_connectivity
    show_volumes_status
    show_recent_logs
    show_quick_access_urls
    show_available_scripts
    
    echo -e "${BLUE}üìä Monitor de estado completado - $(date)${NC}"
    echo "=============================================================================="
}

# Verificar si se pasa argumento --watch
if [ "$1" = "--watch" ]; then
    echo -e "${YELLOW}üîÑ Modo de monitoreo continuo activado (Ctrl+C para salir)${NC}"
    watch -c -n 30 "$0"
else
    main "$@"
fi</code></pre>
            </div>
        </div>

        <!-- Script 4: logs.sh -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <i class="fas fa-file-alt text-purple-600 mr-3"></i>
                logs.sh - Gesti√≥n Avanzada de Logs
            </h2>
            <div class="bg-gray-800 rounded-lg p-4 overflow-x-auto">
                <pre class="text-green-400 text-sm"><code class="language-bash">#!/bin/bash

# =============================================================================
# Business Intelligence Orchestrator v3.1 - Gesti√≥n de Logs
# =============================================================================

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

PROJECT_NAME="bi-orchestrator"

# Funci√≥n para mostrar ayuda
show_help() {
    echo -e "${BLUE}üìã Gesti√≥n de Logs - Business Intelligence Orchestrator v3.1${NC}"
    echo "=============================================================================="
    echo ""
    echo "Uso: $0 [SERVICIO] [OPCIONES]"
    echo ""
    echo -e "${CYAN}Servicios disponibles:${NC}"
    echo "  all                    - Todos los servicios"
    echo "  postgres              - Base de datos PostgreSQL"
    echo "  redis                 - Redis cache"
    echo "  n8n                   - Workflows N8N"
    echo "  web-monitor           - WEB Autom√°tico Competitivo"
    echo "  api-gateway           - API Gateway"
    echo "  data-analytics        - Microservicio de an√°lisis"
    echo "  competitive-intel     - Inteligencia competitiva"
    echo "  business-metrics      - M√©tricas de negocio"
    echo "  frontend              - Frontend React"
    echo "  grafana               - Monitoreo Grafana"
    echo ""
    echo -e "${CYAN}Opciones:${NC}"
    echo "  -f, --follow          - Seguir logs en tiempo real"
    echo "  -t, --tail N          - Mostrar √∫ltimas N l√≠neas (default: 100)"
    echo "  -s, --since TIME      - Mostrar logs desde tiempo espec√≠fico"
    echo "  --errors              - Solo mostrar errores"
    echo "  --export PATH         - Exportar logs a archivo"
    echo "  --clean               - Limpiar logs antiguos"
    echo "  --size                - Mostrar tama√±o de logs"
    echo ""
    echo -e "${CYAN}Ejemplos:${NC}"
    echo "  $0 web-monitor -f              # Seguir logs del WEB Autom√°tico"
    echo "  $0 all --errors                # Solo errores de todos los servicios"
    echo "  $0 postgres -s '1h'            # Logs de PostgreSQL √∫ltima hora"
    echo "  $0 n8n --export /tmp/n8n.log   # Exportar logs de N8N"
}

# Funci√≥n para listar servicios activos
list_active_services() {
    echo -e "${CYAN}üì¶ Servicios activos:${NC}"
    docker-compose ps --services | while read service; do
        status=$(docker-compose ps -q "$service" | xargs docker inspect --format='{{.State.Status}}' 2>/dev/null || echo "stopped")
        if [ "$status" = "running" ]; then
            echo -e "  ${GREEN}‚úÖ $service${NC}"
        else
            echo -e "  ${RED}‚ùå $service${NC} ($status)"
        fi
    done
    echo ""
}

# Funci√≥n para obtener logs de un servicio espec√≠fico
get_service_logs() {
    local service=$1
    local options=$2
    local tail_lines=${3:-100}
    local since=${4:-}
    local follow=${5:-false}
    local errors_only=${6:-false}
    
    echo -e "${BLUE}üìã Logs de $service${NC}"
    echo "=============================================================================="
    
    # Construir comando de docker-compose logs
    local cmd="docker-compose logs"
    
    if [ "$follow" = true ]; then
        cmd="$cmd -f"
    fi
    
    if [ ! -z "$since" ]; then
        cmd="$cmd --since=$since"
    else
        cmd="$cmd --tail=$tail_lines"
    fi
    
    cmd="$cmd $service"
    
    # Ejecutar comando y filtrar errores si es necesario
    if [ "$errors_only" = true ]; then
        eval $cmd 2>&1 | grep -i "error\|exception\|failed\|fatal\|panic\|warn" --color=always
    else
        eval $cmd
    fi
}

# Funci√≥n para exportar logs
export_logs() {
    local service=$1
    local export_path=$2
    local since=${3:-"24h"}
    
    echo -e "${YELLOW}üì§ Exportando logs de $service a $export_path...${NC}"
    
    # Crear directorio si no existe
    mkdir -p "$(dirname "$export_path")"
    
    # Generar header del archivo
    {
        echo "# Business Intelligence Orchestrator v3.1 - Logs Export"
        echo "# Service: $service"
        echo "# Generated: $(date)"
        echo "# Since: $since"
        echo "=============================================================================="
        echo ""
    } > "$export_path"
    
    # Exportar logs
    docker-compose logs --since="$since" "$service" >> "$export_path" 2>&1
    
    local file_size=$(du -h "$export_path" | cut -f1)
    echo -e "${GREEN}‚úÖ Logs exportados: $export_path ($file_size)${NC}"
}

# Funci√≥n para limpiar logs antiguos
clean_old_logs() {
    echo -e "${YELLOW}üßπ Limpiando logs antiguos...${NC}"
    
    # Rotar logs de Docker
    docker system prune -f --filter "until=72h" >/dev/null 2>&1
    
    # Limpiar logs espec√≠ficos del proyecto
    containers=$(docker-compose ps -q)
    for container in $containers; do
        if [ ! -z "$container" ]; then
            name=$(docker inspect --format='{{.Name}}' "$container" | sed 's/\///g')
            log_file=$(docker inspect --format='{{.LogPath}}' "$container" 2>/dev/null)
            
            if [ -f "$log_file" ]; then
                size_before=$(du -h "$log_file" | cut -f1)
                # Mantener solo √∫ltimas 1000 l√≠neas
                tail -n 1000 "$log_file" > "${log_file}.tmp" && mv "${log_file}.tmp" "$log_file"
                size_after=$(du -h "$log_file" | cut -f1)
                echo -e "  ${GREEN}‚úÖ $name:${NC} $size_before ‚Üí $size_after"
            fi
        fi
    done
    
    echo -e "${GREEN}‚úÖ Limpieza de logs completada${NC}"
}

# Funci√≥n para mostrar tama√±o de logs
show_logs_size() {
    echo -e "${CYAN}üíæ Tama√±o de logs por servicio:${NC}"
    echo "=============================================================================="
    
    total_size=0
    containers=$(docker-compose ps -q)
    
    printf "%-25s %-15s %-30s\n" "SERVICIO" "TAMA√ëO" "ARCHIVO DE LOG"
    echo "------------------------------------------------------------------------------"
    
    for container in $containers; do
        if [ ! -z "$container" ]; then
            name=$(docker inspect --format='{{.Name}}' "$container" | sed 's/\///g')
            log_file=$(docker inspect --format='{{.LogPath}}' "$container" 2>/dev/null)
            
            if [ -f "$log_file" ]; then
                size_human=$(du -h "$log_file" | cut -f1)
                size_bytes=$(du -b "$log_file" | cut -f1)
                total_size=$((total_size + size_bytes))
                printf "%-25s %-15s %-30s\n" "$name" "$size_human" "$(basename "$log_file")"
            else
                printf "%-25s %-15s %-30s\n" "$name" "N/A" "Log no encontrado"
            fi
        fi
    done
    
    echo "------------------------------------------------------------------------------"
    total_human=$(echo $total_size | awk '{print ($1/1024/1024 > 1) ? sprintf("%.1f MB", $1/1024/1024) : sprintf("%.1f KB", $1/1024)}')
    printf "%-25s %-15s\n" "TOTAL" "$total_human"
    echo ""
}

# Funci√≥n para monitoreo de logs en tiempo real
realtime_monitor() {
    local services=("$@")
    
    echo -e "${BLUE}üîÑ Monitor de logs en tiempo real${NC}"
    echo -e "${YELLOW}Servicios: ${services[*]}${NC}"
    echo -e "${YELLOW}Presiona Ctrl+C para salir${NC}"
    echo "=============================================================================="
    
    # Crear comando para m√∫ltiples servicios
    local cmd="docker-compose logs -f --tail=50"
    for service in "${services[@]}"; do
        cmd="$cmd $service"
    done
    
    # Ejecutar con colores y timestamps
    eval $cmd | while read line; do
        timestamp=$(date '+%H:%M:%S')
        echo -e "${CYAN}[$timestamp]${NC} $line"
    done
}

# Funci√≥n para an√°lisis de logs
analyze_logs() {
    local service=$1
    local since=${2:-"1h"}
    
    echo -e "${CYAN}üìä An√°lisis de logs para $service (√∫ltimas ${since})${NC}"
    echo "=============================================================================="
    
    local logs=$(docker-compose logs --since="$since" "$service" 2>&1)
    
    # Contar tipos de eventos
    local error_count=$(echo "$logs" | grep -ci "error\|exception\|failed\|fatal" || echo "0")
    local warn_count=$(echo "$logs" | grep -ci "warn\|warning" || echo "0")
    local info_count=$(echo "$logs" | grep -ci "info\|success\|completed" || echo "0")
    local total_lines=$(echo "$logs" | wc -l)
    
    echo -e "${RED}‚ùå Errores:${NC} $error_count"
    echo -e "${YELLOW}‚ö†Ô∏è  Advertencias:${NC} $warn_count"
    echo -e "${GREEN}‚úÖ Informaci√≥n:${NC} $info_count"
    echo -e "${BLUE}üìÑ Total l√≠neas:${NC} $total_lines"
    echo ""
    
    # Mostrar errores m√°s frecuentes
    if [ $error_count -gt 0 ]; then
        echo -e "${CYAN}üîç Errores m√°s frecuentes:${NC}"
        echo "$logs" | grep -i "error\|exception\|failed\|fatal" | sort | uniq -c | sort -nr | head -5
        echo ""
    fi
    
    # Mostrar actividad por hora
    echo -e "${CYAN}üìà Actividad por hora:${NC}"
    echo "$logs" | grep -E "[0-9]{2}:[0-9]{2}:[0-9]{2}" | cut -c12-13 | sort | uniq -c | sort -nr | head -10
    echo ""
}

# Funci√≥n principal
main() {
    local service=${1:-}
    local follow=false
    local tail_lines=100
    local since=""
    local errors_only=false
    local export_path=""
    local clean_logs=false
    local show_size=false
    local analyze=false
    
    # Parsear argumentos
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            -t|--tail)
                tail_lines="$2"
                shift 2
                ;;
            -s|--since)
                since="$2"
                shift 2
                ;;
            --errors)
                errors_only=true
                shift
                ;;
            --export)
                export_path="$2"
                shift 2
                ;;
            --clean)
                clean_logs=true
                shift
                ;;
            --size)
                show_size=true
                shift
                ;;
            --analyze)
                analyze=true
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}‚ùå Opci√≥n desconocida: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Verificar que Docker Compose est√© disponible
    if ! command -v docker-compose >/dev/null 2>&1; then
        echo -e "${RED}‚ùå Docker Compose no est√° disponible${NC}"
        exit 1
    fi
    
    # Ejecutar acciones especiales
    if [ "$clean_logs" = true ]; then
        clean_old_logs
        exit 0
    fi
    
    if [ "$show_size" = true ]; then
        show_logs_size
        exit 0
    fi
    
    # Mostrar ayuda si no se especifica servicio
    if [ -z "$service" ]; then
        show_help
        echo ""
        list_active_services
        exit 0
    fi
    
    # Manejar servicio "all"
    if [ "$service" = "all" ]; then
        if [ "$follow" = true ]; then
            services=($(docker-compose config --services))
            realtime_monitor "${services[@]}"
        elif [ "$analyze" = true ]; then
            services=($(docker-compose config --services))
            for svc in "${services[@]}"; do
                analyze_logs "$svc" "$since"
                echo ""
            done
        elif [ ! -z "$export_path" ]; then
            export_logs "all" "$export_path" "$since"
        else
            services=($(docker-compose config --services))
            for svc in "${services[@]}"; do
                get_service_logs "$svc" "" "$tail_lines" "$since" false "$errors_only"
                echo ""
            done
        fi
        exit 0
    fi
    
    # Verificar que el servicio existe
    if ! docker-compose config --services | grep -q "^$service$"; then
        echo -e "${RED}‚ùå Servicio '$service' no encontrado${NC}"
        echo ""
        list_active_services
        exit 1
    fi
    
    # Ejecutar an√°lisis si se solicita
    if [ "$analyze" = true ]; then
        analyze_logs "$service" "$since"
        exit 0
    fi
    
    # Exportar logs si se solicita
    if [ ! -z "$export_path" ]; then
        export_logs "$service" "$export_path" "$since"
        exit 0
    fi
    
    # Mostrar logs del servicio
    get_service_logs "$service" "" "$tail_lines" "$since" "$follow" "$errors_only"
}

# Ejecutar funci√≥n principal con todos los argumentos
main "$@"</code></pre>
            </div>
        </div>

        <!-- Script 5: maintenance.sh -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <i class="fas fa-wrench text-orange-600 mr-3"></i>
                maintenance.sh - Mantenimiento Automatizado
            </h2>
            <div class="bg-gray-800 rounded-lg p-4 overflow-x-auto">
                <pre class="text-green-400 text-sm"><code class="language-bash">#!/bin/bash

# =============================================================================
# Business Intelligence Orchestrator v3.1 - Mantenimiento Automatizado
# =============================================================================

set -e

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

PROJECT_NAME="bi-orchestrator"
MAINTENANCE_LOG="/var/log/${PROJECT_NAME}_maintenance.log"
BACKUP_DIR="./backups"

# Funci√≥n de logging
log() {
    local level=$1
    shift
    local message="$@"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "[$timestamp] $level: $message" | tee -a "$MAINTENANCE_LOG"
}

# Mostrar ayuda
show_help() {
    echo -e "${BLUE}üîß Mantenimiento Automatizado - Business Intelligence Orchestrator v3.1${NC}"
    echo "=============================================================================="
    echo ""
    echo "Uso: $0 [TAREA] [OPCIONES]"
    echo ""
    echo -e "${CYAN}Tareas disponibles:${NC}"
    echo "  daily                  - Mantenimiento diario completo"
    echo "  weekly                 - Mantenimiento semanal completo"
    echo "  database               - Mantenimiento de base de datos"
    echo "  cache                  - Limpiar y optimizar cache"
    echo "  logs                   - Rotar y limpiar logs"
    echo "  docker                 - Limpiar Docker (im√°genes, contenedores)"
    echo "  backup                 - Crear backup completo"
    echo "  health-check           - Verificaci√≥n completa de salud"
    echo "  optimize               - Optimizar rendimiento del sistema"
    echo "  security               - Verificaciones de seguridad"
    echo ""
    echo -e "${CYAN}Opciones:${NC}"
    echo "  --dry-run              - Mostrar qu√© se har√≠a sin ejecutar"
    echo "  --force                - Forzar operaciones sin confirmaci√≥n"
    echo "  --quiet                - Modo silencioso (solo errores)"
    echo "  --schedule             - Configurar en crontab"
    echo ""
    echo -e "${CYAN}Ejemplos:${NC}"
    echo "  $0 daily               # Mantenimiento diario"
    echo "  $0 database --dry-run  # Ver qu√© mantenimiento de BD se har√≠a"
    echo "  $0 weekly --force      # Mantenimiento semanal sin confirmaciones"
}

# Verificar prerrequisitos
check_prerequisites() {
    log "${BLUE}INFO${NC}" "Verificando prerrequisitos..."
    
    # Verificar que el sistema est√© ejecut√°ndose
    if ! docker-compose ps | grep -q "Up"; then
        log "${RED}ERROR${NC}" "El sistema no est√° ejecut√°ndose"
        return 1
    fi
    
    # Crear directorio de logs si no existe
    mkdir -p "$(dirname "$MAINTENANCE_LOG")" 2>/dev/null || true
    
    # Crear directorio de backups si no existe
    mkdir -p "$BACKUP_DIR" 2>/dev/null || true
    
    log "${GREEN}INFO${NC}" "Prerrequisitos verificados"
    return 0
}

# Mantenimiento de base de datos
maintain_database() {
    log "${YELLOW}INFO${NC}" "Iniciando mantenimiento de base de datos..."
    
    local dry_run=$1
    
    if [ "$dry_run" = "true" ]; then
        log "${CYAN}DRY-RUN${NC}" "Se ejecutar√≠an las siguientes tareas de BD:"
        echo "  - VACUUM ANALYZE en todas las tablas"
        echo "  - Reindexaci√≥n de √≠ndices fragmentados"
        echo "  - Limpieza de datos antiguos (>30 d√≠as)"
        echo "  - Actualizaci√≥n de estad√≠sticas"
        return 0
    fi
    
    # Backup antes de mantenimiento
    log "${BLUE}INFO${NC}" "Creando backup antes del mantenimiento..."
    ./scripts/backup.sh --quick || {
        log "${RED}ERROR${NC}" "Fall√≥ el backup pre-mantenimiento"
        return 1
    }
    
    # Ejecutar VACUUM ANALYZE
    log "${BLUE}INFO${NC}" "Ejecutando VACUUM ANALYZE..."
    docker-compose exec -T postgres psql -U bi_user -d bi_orchestrator -c "VACUUM ANALYZE;" || {
        log "${RED}ERROR${NC}" "Fall√≥ VACUUM ANALYZE"
        return 1
    }
    
    # Reindexar tablas principales
    log "${BLUE}INFO${NC}" "Reindexando tablas principales..."
    tables=("competitive_data" "market_intelligence" "business_metrics" "customer_interactions")
    for table in "${tables[@]}"; do
        docker-compose exec -T postgres psql -U bi_user -d bi_orchestrator -c "REINDEX TABLE $table;" || true
    done
    
    # Limpiar datos antiguos
    log "${BLUE}INFO${NC}" "Limpiando datos antiguos (>30 d√≠as)..."
    docker-compose exec -T postgres psql -U bi_user -d bi_orchestrator -c "
        DELETE FROM competitive_data WHERE created_at < NOW() - INTERVAL '30 days';
        DELETE FROM cache_entries WHERE expires_at < NOW();
        DELETE FROM system_logs WHERE created_at < NOW() - INTERVAL '7 days';
    " || true
    
    # Actualizar estad√≠sticas
    log "${BLUE}INFO${NC}" "Actualizando estad√≠sticas de la base de datos..."
    docker-compose exec -T postgres psql -U bi_user -d bi_orchestrator -c "ANALYZE;" || true
    
    log "${GREEN}SUCCESS${NC}" "Mantenimiento de base de datos completado"
}

# Mantenimiento de cache Redis
maintain_cache() {
    log "${YELLOW}INFO${NC}" "Iniciando mantenimiento de cache Redis..."
    
    local dry_run=$1
    
    if [ "$dry_run" = "true" ]; then
        log "${CYAN}DRY-RUN${NC}" "Se ejecutar√≠an las siguientes tareas de cache:"
        echo "  - Limpiar keys expirados"
        echo "  - Compactar memoria Redis"
        echo "  - Verificar integridad de datos"
        echo "  - Optimizar configuraci√≥n"
        return 0
    fi
    
    # Obtener estad√≠sticas antes
    local stats_before=$(docker-compose exec -T redis-master redis-cli INFO memory | grep used_memory_human)
    log "${BLUE}INFO${NC}" "Memoria Redis antes: $stats_before"
    
    # Limpiar keys expirados manualmente
    log "${BLUE}INFO${NC}" "Limpiando keys expirados..."
    docker-compose exec -T redis-master redis-cli --scan --pattern "*" | while read key; do
        docker-compose exec -T redis-master redis-cli TTL "$key" | grep -q "^-1$" || continue
        # Key sin TTL, verificar si es cache antiguo
        if echo "$key" | grep -q "cache:"; then
            docker-compose exec -T redis-master redis-cli DEL "$key" >/dev/null 2>&1 || true
        fi
    done
    
    # Compactar memoria
    log "${BLUE}INFO${NC}" "Compactando memoria Redis..."
    docker-compose exec -T redis-master redis-cli MEMORY PURGE >/dev/null 2>&1 || true
    
    # Verificar integridad
    log "${BLUE}INFO${NC}" "Verificando integridad de Redis..."
    docker-compose exec -T redis-master redis-cli PING | grep -q "PONG" || {
        log "${RED}ERROR${NC}" "Redis no responde correctamente"
        return 1
    }
    
    # Estad√≠sticas despu√©s
    local stats_after=$(docker-compose exec -T redis-master redis-cli INFO memory | grep used_memory_human)
    log "${GREEN}SUCCESS${NC}" "Memoria Redis despu√©s: $stats_after"
    log "${GREEN}SUCCESS${NC}" "Mantenimiento de cache completado"
}

# Limpiar logs del sistema
maintain_logs() {
    log "${YELLOW}INFO${NC}" "Iniciando mantenimiento de logs..."
    
    local dry_run=$1
    
    if [ "$dry_run" = "true" ]; then
        log "${CYAN}DRY-RUN${NC}" "Se ejecutar√≠an las siguientes tareas de logs:"
        echo "  - Rotar logs de aplicaci√≥n"
        echo "  - Comprimir logs antiguos"
        echo "  - Eliminar logs >7 d√≠as"
        echo "  - Limpiar logs de Docker"
        return 0
    fi
    
    # Rotar logs de aplicaci√≥n
    log "${BLUE}INFO${NC}" "Rotando logs de aplicaci√≥n..."
    if [ -f "$MAINTENANCE_LOG" ] && [ $(stat -f%z "$MAINTENANCE_LOG" 2>/dev/null || stat -c%s "$MAINTENANCE_LOG" 2>/dev/null || echo 0) -gt 10485760 ]; then
        mv "$MAINTENANCE_LOG" "${MAINTENANCE_LOG}.$(date +%Y%m%d)"
        touch "$MAINTENANCE_LOG"
    fi
    
    # Limpiar logs usando el script dedicado
    log "${BLUE}INFO${NC}" "Ejecutando limpieza de logs..."
    ./scripts/logs.sh --clean || true
    
    # Comprimir logs antiguos
    log "${BLUE}INFO${NC}" "Comprimiendo logs antiguos..."
    find . -name "*.log.*" -mtime +1 ! -name "*.gz" -exec gzip {} \; 2>/dev/null || true
    
    # Eliminar logs muy antiguos
    log "${BLUE}INFO${NC}" "Eliminando logs antiguos (>7 d√≠as)..."
    find . -name "*.log.*.gz" -mtime +7 -delete 2>/dev/null || true
    
    log "${GREEN}SUCCESS${NC}" "Mantenimiento de logs completado"
}

# Limpiar Docker
maintain_docker() {
    log "${YELLOW}INFO${NC}" "Iniciando mantenimiento de Docker..."
    
    local dry_run=$1
    
    if [ "$dry_run" = "true" ]; then
        log "${CYAN}DRY-RUN${NC}" "Se ejecutar√≠an las siguientes tareas de Docker:"
        echo "  - Eliminar contenedores detenidos"
        echo "  - Eliminar im√°genes no utilizadas"
        echo "  - Eliminar vol√∫menes hu√©rfanos"
        echo "  - Eliminar redes no utilizadas"
        return 0
    fi
    
    # Obtener estad√≠sticas antes
    local space_before=$(docker system df --format "table {{.Type}}\t{{.TotalCount}}\t{{.Size}}" | grep "Images\|Containers\|Local Volumes")
    log "${BLUE}INFO${NC}" "Espacio Docker antes del mantenimiento:"
    echo "$space_before"
    
    # Limpiar contenedores detenidos
    log "${BLUE}INFO${NC}" "Eliminando contenedores detenidos..."
    docker container prune -f >/dev/null 2>&1 || true
    
    # Limpiar im√°genes no utilizadas (excepto las del proyecto)
    log "${BLUE}INFO${NC}" "Eliminando im√°genes no utilizadas..."
    docker image prune -f >/dev/null 2>&1 || true
    
    # Limpiar vol√∫menes hu√©rfanos (con cuidado)
    log "${BLUE}INFO${NC}" "Eliminando vol√∫menes hu√©rfanos..."
    docker volume prune -f >/dev/null 2>&1 || true
    
    # Limpiar redes no utilizadas
    log "${BLUE}INFO${NC}" "Eliminando redes no utilizadas..."
    docker network prune -f >/dev/null 2>&1 || true
    
    # Estad√≠sticas despu√©s
    local space_after=$(docker system df --format "table {{.Type}}\t{{.TotalCount}}\t{{.Size}}" | grep "Images\|Containers\|Local Volumes")
    log "${BLUE}INFO${NC}" "Espacio Docker despu√©s del mantenimiento:"
    echo "$space_after"
    
    log "${GREEN}SUCCESS${NC}" "Mantenimiento de Docker completado"
}

# Verificaci√≥n de salud completa
health_check() {
    log "${YELLOW}INFO${NC}" "Iniciando verificaci√≥n de salud del sistema..."
    
    local issues=0
    
    # Verificar servicios cr√≠ticos
    log "${BLUE}INFO${NC}" "Verificando servicios cr√≠ticos..."
    critical_services=("postgres" "redis-master" "n8n" "web-monitor" "api-gateway")
    for service in "${critical_services[@]}"; do
        if docker-compose ps "$service" | grep -q "Up"; then
            log "${GREEN}OK${NC}" "$service est√° ejecut√°ndose"
        else
            log "${RED}CRITICAL${NC}" "$service NO est√° ejecut√°ndose"
            ((issues++))
        fi
    done
    
    # Verificar conectividad de base de datos
    log "${BLUE}INFO${NC}" "Verificando conectividad de base de datos..."
    if docker-compose exec -T postgres pg_isready -U bi_user >/dev/null 2>&1; then
        log "${GREEN}OK${NC}" "Base de datos conectiva"
    else
        log "${RED}CRITICAL${NC}" "Base de datos NO conectiva"
        ((issues++))
    fi
    
    # Verificar Redis
    log "${BLUE}INFO${NC}" "Verificando Redis..."
    if docker-compose exec -T redis-master redis-cli ping | grep -q "PONG"; then
        log "${GREEN}OK${NC}" "Redis conectivo"
    else
        log "${RED}CRITICAL${NC}" "Redis NO conectivo"
        ((issues++))
    fi
    
    # Verificar espacio en disco
    log "${BLUE}INFO${NC}" "Verificando espacio en disco..."
    local disk_usage=$(df . | tail -1 | awk '{print $5}' | sed 's/%//')
    if [ $disk_usage -lt 80 ]; then
        log "${GREEN}OK${NC}" "Espacio en disco: ${disk_usage}%"
    elif [ $disk_usage -lt 90 ]; then
        log "${YELLOW}WARNING${NC}" "Espacio en disco: ${disk_usage}% (advertencia)"
        ((issues++))
    else
        log "${RED}CRITICAL${NC}" "Espacio en disco: ${disk_usage}% (cr√≠tico)"
        ((issues++))
    fi
    
    # Verificar memoria
    log "${BLUE}INFO${NC}" "Verificando memoria del sistema..."
    local mem_usage=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}')
    if [ $mem_usage -lt 80 ]; then
        log "${GREEN}OK${NC}" "Uso de memoria: ${mem_usage}%"
    elif [ $mem_usage -lt 90 ]; then
        log "${YELLOW}WARNING${NC}" "Uso de memoria: ${mem_usage}% (advertencia)"
    else
        log "${RED}CRITICAL${NC}" "Uso de memoria: ${mem_usage}% (cr√≠tico)"
        ((issues++))
    fi
    
    # Resumen final
    if [ $issues -eq 0 ]; then
        log "${GREEN}SUCCESS${NC}" "Verificaci√≥n de salud completada - No se encontraron problemas"
        return 0
    else
        log "${RED}WARNING${NC}" "Verificaci√≥n de salud completada - $issues problemas encontrados"
        return 1
    fi
}

# Optimizar rendimiento del sistema
optimize_system() {
    log "${YELLOW}INFO${NC}" "Iniciando optimizaci√≥n del sistema..."
    
    local dry_run=$1
    
    if [ "$dry_run" = "true" ]; then
        log "${CYAN}DRY-RUN${NC}" "Se ejecutar√≠an las siguientes optimizaciones:"
        echo "  - Optimizar configuraci√≥n de PostgreSQL"
        echo "  - Ajustar configuraci√≥n de Redis"
        echo "  - Optimizar memoria de contenedores"
        echo "  - Limpiar cache de aplicaci√≥n"
        return 0
    fi
    
    # Optimizar PostgreSQL
    log "${BLUE}INFO${NC}" "Optimizando configuraci√≥n de PostgreSQL..."
    docker-compose exec -T postgres psql -U bi_user -d bi_orchestrator -c "
        -- Actualizar estad√≠sticas para el optimizador
        ANALYZE;
        -- Optimizar configuraci√≥n autom√°ticamente
        SELECT pg_stat_reset();
    " || true
    
    # Optimizar Redis
    log "${BLUE}INFO${NC}" "Optimizando Redis..."
    docker-compose exec -T redis-master redis-cli CONFIG SET save "900 1 300 10 60 10000" >/dev/null 2>&1 || true
    docker-compose exec -T redis-master redis-cli BGSAVE >/dev/null 2>&1 || true
    
    # Limpiar cache de aplicaci√≥n
    log "${BLUE}INFO${NC}" "Limpiando cache de aplicaci√≥n..."
    maintain_cache false
    
    # Reiniciar servicios para aplicar optimizaciones
    log "${BLUE}INFO${NC}" "Reiniciando servicios para aplicar optimizaciones..."
    docker-compose restart api-gateway data-analytics competitive-intelligence business-metrics >/dev/null 2>&1 || true
    
    log "${GREEN}SUCCESS${NC}" "Optimizaci√≥n del sistema completada"
}

# Mantenimiento diario
daily_maintenance() {
    log "${CYAN}INFO${NC}" "=== INICIANDO MANTENIMIENTO DIARIO ==="
    
    local dry_run=$1
    local force=$2
    
    if [ "$force" != "true" ] && [ "$dry_run" != "true" ]; then
        echo -e "${YELLOW}¬øContinuar con el mantenimiento diario? (y/N)${NC}"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log "${BLUE}INFO${NC}" "Mantenimiento cancelado por el usuario"
            exit 0
        fi
    fi
    
    # Tareas diarias
    maintain_logs "$dry_run"
    maintain_cache "$dry_run"
    maintain_docker "$dry_run"
    health_check
    
    log "${CYAN}INFO${NC}" "=== MANTENIMIENTO DIARIO COMPLETADO ==="
}

# Mantenimiento semanal
weekly_maintenance() {
    log "${CYAN}INFO${NC}" "=== INICIANDO MANTENIMIENTO SEMANAL ==="
    
    local dry_run=$1
    local force=$2
    
    if [ "$force" != "true" ] && [ "$dry_run" != "true" ]; then
        echo -e "${YELLOW}¬øContinuar con el mantenimiento semanal? (y/N)${NC}"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log "${BLUE}INFO${NC}" "Mantenimiento cancelado por el usuario"
            exit 0
        fi
    fi
    
    # Tareas semanales (incluye diarias)
    daily_maintenance "$dry_run" true
    maintain_database "$dry_run"
    optimize_system "$dry_run"
    
    # Backup completo
    if [ "$dry_run" != "true" ]; then
        ./scripts/backup.sh --full || log "${RED}ERROR${NC}" "Fall√≥ el backup semanal"
    fi
    
    log "${CYAN}INFO${NC}" "=== MANTENIMIENTO SEMANAL COMPLETADO ==="
}

# Configurar en crontab
schedule_maintenance() {
    echo -e "${BLUE}üìÖ Configurar mantenimiento autom√°tico en crontab${NC}"
    echo "=============================================================================="
    
    local script_path=$(realpath "$0")
    
    echo -e "${CYAN}Configuraciones recomendadas:${NC}"
    echo ""
    echo "# Mantenimiento diario a las 2:00 AM"
    echo "0 2 * * * $script_path daily --force > /dev/null 2>&1"
    echo ""
    echo "# Mantenimiento semanal los domingos a las 3:00 AM"
    echo "0 3 * * 0 $script_path weekly --force > /dev/null 2>&1"
    echo ""
    echo "# Verificaci√≥n de salud cada 4 horas"
    echo "0 */4 * * * $script_path health-check > /dev/null 2>&1"
    echo ""
    
    echo -e "${YELLOW}¬øAgregar estas configuraciones al crontab actual? (y/N)${NC}"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        {
            echo "# Business Intelligence Orchestrator v3.1 - Mantenimiento autom√°tico"
            echo "0 2 * * * $script_path daily --force > /dev/null 2>&1"
            echo "0 3 * * 0 $script_path weekly --force > /dev/null 2>&1"
            echo "0 */4 * * * $script_path health-check > /dev/null 2>&1"
        } | crontab -
        echo -e "${GREEN}‚úÖ Configuraciones agregadas al crontab${NC}"
    fi
}

# Funci√≥n principal
main() {
    local task=${1:-}
    local dry_run=false
    local force=false
    local quiet=false
    
    # Parsear argumentos
    shift 2>/dev/null || true
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --quiet)
                quiet=true
                shift
                ;;
            --schedule)
                schedule_maintenance
                exit 0
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                echo -e "${RED}‚ùå Opci√≥n desconocida: $1${NC}"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Redirigir output si es modo silencioso
    if [ "$quiet" = true ]; then
        exec 1>/dev/null
    fi
    
    # Verificar prerrequisitos
    if ! check_prerequisites; then
        exit 1
    fi
    
    # Ejecutar tarea solicitada
    case $task in
        daily)
            daily_maintenance "$dry_run" "$force"
            ;;
        weekly)
            weekly_maintenance "$dry_run" "$force"
            ;;
        database)
            maintain_database "$dry_run"
            ;;
        cache)
            maintain_cache "$dry_run"
            ;;
        logs)
            maintain_logs "$dry_run"
            ;;
        docker)
            maintain_docker "$dry_run"
            ;;
        backup)
            ./scripts/backup.sh --full
            ;;
        health-check)
            health_check
            ;;
        optimize)
            optimize_system "$dry_run"
            ;;
        "")
            show_help
            echo ""
            log "${BLUE}INFO${NC}" "Especifica una tarea de mantenimiento para continuar"
            ;;
        *)
            echo -e "${RED}‚ùå Tarea desconocida: $task${NC}"
            show_help
            exit 1
            ;;
    esac
}

# Ejecutar funci√≥n principal con todos los argumentos
main "$@"</code></pre>
            </div>
        </div>

        <!-- Configuraci√≥n CI/CD -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <i class="fas fa-cloud-upload-alt text-indigo-600 mr-3"></i>
                Configuraci√≥n CI/CD - GitHub Actions
            </h2>
            <div class="bg-gray-800 rounded-lg p-4 overflow-x-auto">
                <pre class="text-green-400 text-sm"><code class="language-yaml"># .github/workflows/deploy.yml
name: Business Intelligence Orchestrator v3.1 - Deploy

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  PROJECT_NAME: bi-orchestrator
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job de testing
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9, 3.10, 3.11]
        node-version: [16, 18]
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout c√≥digo
      uses: actions/checkout@v3

    - name: Setup Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}

    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/pip
          ~/.npm
          node_modules
        key: ${{ runner.os }}-deps-${{ hashFiles('**/requirements.txt', '**/package-lock.json') }}

    - name: Instalar dependencias Python
      run: |
        python -m pip install --upgrade pip
        pip install -r backend/requirements.txt
        pip install pytest pytest-cov black flake8

    - name: Instalar dependencias Node.js
      run: |
        cd frontend
        npm ci

    - name: Linter Python (Black + Flake8)
      run: |
        black --check backend/
        flake8 backend/ --max-line-length=88

    - name: Linter Frontend (ESLint + Prettier)
      run: |
        cd frontend
        npm run lint
        npm run format-check

    - name: Tests Backend
      env:
        DATABASE_URL: postgresql://postgres:test_password@localhost/test_db
        REDIS_URL: redis://localhost:6379
      run: |
        cd backend
        pytest tests/ -v --cov=./ --cov-report=xml

    - name: Tests Frontend
      run: |
        cd frontend
        npm test -- --coverage --watchAll=false

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./backend/coverage.xml,./frontend/coverage/lcov.info

  # Job de build de im√°genes Docker
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout c√≥digo
      uses: actions/checkout@v3

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    # Build WEB AUTOM√ÅTICO COMPETITIVO
    - name: Build Web Monitor
      uses: docker/build-push-action@v4
      with:
        context: ./web-monitor
        file: ./Dockerfile.web-monitor
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-web-monitor:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # Build Backend Microservices
    - name: Build Backend Services
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # Build Frontend
    - name: Build Frontend
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Job de deployment a staging
  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - name: Checkout c√≥digo
      uses: actions/checkout@v3

    - name: Setup deployment tools
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: Configure kubeconfig
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_STAGING }}
      run: |
        mkdir -p ~/.kube
        echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config

    - name: Deploy to staging
      env:
        IMAGE_TAG: ${{ github.sha }}
        NAMESPACE: bi-orchestrator-staging
      run: |
        # Actualizar manifiestos con nueva imagen
        sed -i "s/IMAGE_TAG/$IMAGE_TAG/g" k8s/staging/*.yaml
        
        # Aplicar configuraciones
        kubectl apply -f k8s/staging/ -n $NAMESPACE
        
        # Esperar deployment
        kubectl rollout status deployment/bi-orchestrator -n $NAMESPACE

    - name: Run smoke tests
      run: |
        # Esperar que los servicios est√©n listos
        sleep 60
        
        # URL de staging
        STAGING_URL=$(kubectl get ingress bi-orchestrator-ingress -n bi-orchestrator-staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        # Tests b√°sicos de humo
        curl -f "$STAGING_URL/api/health" || exit 1
        curl -f "$STAGING_URL/" || exit 1

  # Job de deployment a producci√≥n
  deploy-production:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - name: Checkout c√≥digo
      uses: actions/checkout@v3

    - name: Deploy to production
      env:
        DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
        DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
        DEPLOY_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Configurar SSH
        mkdir -p ~/.ssh
        echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        # Crear script de deployment
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        cd /opt/bi-orchestrator
        
        # Backup antes del deployment
        ./scripts/backup.sh --full
        
        # Actualizar im√°genes en docker-compose
        export IMAGE_TAG=$1
        sed -i "s/IMAGE_TAG/$IMAGE_TAG/g" docker-compose.prod.yml
        
        # Deployment con rolling update
        docker-compose -f docker-compose.prod.yml pull
        docker-compose -f docker-compose.prod.yml up -d --remove-orphans
        
        # Verificar que todo est√© funcionando
        sleep 30
        ./scripts/status.sh
        EOF
        
        chmod +x deploy.sh
        
        # Ejecutar deployment remoto
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          deploy.sh $DEPLOY_USER@$DEPLOY_HOST:/tmp/deploy.sh
        
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
          $DEPLOY_USER@$DEPLOY_HOST \
          "/tmp/deploy.sh $IMAGE_TAG"

    - name: Production smoke tests
      env:
        PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
      run: |
        # Esperar que el deployment est√© completo
        sleep 120
        
        # Tests de producci√≥n
        curl -f "$PRODUCTION_URL/api/health" || exit 1
        curl -f "$PRODUCTION_URL/" || exit 1
        
        # Verificar WEB AUTOM√ÅTICO COMPETITIVO
        curl -f "$PRODUCTION_URL/api/competitive/status" || exit 1

    - name: Notificar √©xito
      uses: 8398a7/action-slack@v3
      if: success()
      with:
        status: success
        text: 'üöÄ Business Intelligence Orchestrator v3.1 deployado exitosamente a producci√≥n!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

    - name: Notificar fallo
      uses: 8398a7/action-slack@v3
      if: failure()
      with:
        status: failure
        text: '‚ùå Fall√≥ el deployment de Business Intelligence Orchestrator v3.1 a producci√≥n'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # Job de limpieza
  cleanup:
    needs: [deploy-staging, deploy-production]
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Limpiar im√°genes antiguas
      uses: actions/delete-package-versions@v4
      with:
        package-name: ${{ env.IMAGE_NAME }}
        package-type: container
        min-versions-to-keep: 10
        delete-only-pre-release-versions: true</code></pre>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div class="bg-gradient-to-r from-blue-900 via-purple-900 to-indigo-900 text-white py-4 mt-8">
        <div class="container mx-auto px-4 text-center">
            <div class="flex items-center justify-center space-x-4">
                <i class="fas fa-tools text-2xl"></i>
                <span class="text-lg font-semibold">Business Intelligence Orchestrator v3.1 - Scripts de Deployment</span>
                <i class="fas fa-rocket text-2xl"></i>
            </div>
            <p class="text-blue-200 mt-2">Sistema de mantenimiento y deployment automatizado</p>
        </div>
    </div>
</body>
</html>
    <script id="html_badge_script1">
        window.__genspark_remove_badge_link = "https://www.genspark.ai/api/html_badge/" +
            "remove_badge?token=To%2FBnjzloZ3UfQdcSaYfDh0vOzivivz7Q%2FPaOrnS7bZq7A0iWZrpEkBRS7UV47BR03uBCwVpm2GpWl8Xy6hc0CfphMxX4ENaUlt7yvn%2BmH5sz0c8GHhUE6DktsvUsH3bQ%2BcG%2B3D6UcUrwNPjUkzWA5WkXtlKE45h7ItVZtcQkK22czxGa6b1mkTcpqRUsjd0R8BaXVY26QO1lmoTza6e%2FsrkcIk8gXX9OCmXtM6VsgYWiA%2Bxmc8i%2Bo8%2FqgeXsWKHbsi9O3ktLgUWdMV9DghV7HVT7a6fE%2BNl4O1fknqsUeJXwgI1SyZOjdxzoli9g6s0atUxwtlnCV16Hr3ilAv8mAojO22vJJmjbPIcunjRFWV%2Bz8qvABgLwdteTo5gluydHJMPZp8WAVspodTXFPkZqmTmxaSRF7grFrV7B9ddVpkzbPx25mwoJqIIgse2n0F6nAKXHXSXXNVqTPcXBuctgh4oHZq1f9%2BPFWCGIKgohwvnzlj%2FkiGTh%2B5DckBMszuykadXYl883C%2BYSE36GMk1ildHcMPvj948ExSbXQJC5No%3D";
        window.__genspark_locale = "es-ES";
        window.__genspark_token = "To/BnjzloZ3UfQdcSaYfDh0vOzivivz7Q/PaOrnS7bZq7A0iWZrpEkBRS7UV47BR03uBCwVpm2GpWl8Xy6hc0CfphMxX4ENaUlt7yvn+mH5sz0c8GHhUE6DktsvUsH3bQ+cG+3D6UcUrwNPjUkzWA5WkXtlKE45h7ItVZtcQkK22czxGa6b1mkTcpqRUsjd0R8BaXVY26QO1lmoTza6e/srkcIk8gXX9OCmXtM6VsgYWiA+xmc8i+o8/qgeXsWKHbsi9O3ktLgUWdMV9DghV7HVT7a6fE+Nl4O1fknqsUeJXwgI1SyZOjdxzoli9g6s0atUxwtlnCV16Hr3ilAv8mAojO22vJJmjbPIcunjRFWV+z8qvABgLwdteTo5gluydHJMPZp8WAVspodTXFPkZqmTmxaSRF7grFrV7B9ddVpkzbPx25mwoJqIIgse2n0F6nAKXHXSXXNVqTPcXBuctgh4oHZq1f9+PFWCGIKgohwvnzlj/kiGTh+5DckBMszuykadXYl883C+YSE36GMk1ildHcMPvj948ExSbXQJC5No=";
    </script>
    
    <script id="html_notice_dialog_script" src="https://www.genspark.ai/notice_dialog.js"></script>
    